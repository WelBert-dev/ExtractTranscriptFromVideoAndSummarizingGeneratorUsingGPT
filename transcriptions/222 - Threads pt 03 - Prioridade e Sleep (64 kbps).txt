 Fala galera, devido a hoje, bem-vindos novamente ao curso Maratana Java, como sempre, com agradecimento, um abraço muito especial para todas, e a galera que é bem-vindo ao nosso canal, a continuidade da nossa aula de threads, e nós vamos falar sobre duas coisas, prioridade e como colocar uma thread para dormir. Bom, então todas as threads têm uma determinada prioridade. Primeiramente, vamos ver aqui uma coisa interessante, que você pode dar nome para as threads, o construador das threads é sobrecarregado, então você pode dar um nome aqui para elas, por exemplo, essa aqui é a thread T1, essa daqui é a thread T2, a gente pode colocar T1A, T2B, copiei esse cara aqui, contra o C, contra o V, contra o C, contra o V aqui, então você tem T3, T4, C e D, agora você executa agora o nome das threads que vai aparecer no console, é esse aqui. Bom, então, vamos lá, prioridade das threads, as threads têm uma prioridade, geralmente a prioridade ela vai de 1 a 10, você pode setar, por exemplo, digamos que você gostaria que a T4 começasse primeiro, então você pode utilizar um método aqui, set priority, geralmente vai de 1 a 10, mas a JVM é uma especificação, vocês têm vários tipos de JVMs, de implementação de JVM, por exemplo, você tem OpenJDK, você tem Adoroco, acho que a Microsoft está fazendo uma agora, ou seja, a implementação pode ser diferente, então em algumas vai de 1 a 10, sendo 1 a menor prioridade e 10 a maior prioridade, mas o que é o considerado você utilizar? Utilizar aqui o thread.maxpriority, na verdade você tem 3, você tem threadminimpriority, normpriority e maxpriority, você pode ver que minima é 1, 5 e 10, então o que você está dizendo quando você coloca uma prioridade a 10? Você está dizendo que você está dando uma indicação para o scheduler para ele dar uma prioridade para essa thread 4, e enfim, é que vai ter prioridade? Não, não é garantido que tenha prioridade, mas você está dando uma indicação, aqui nós podemos ver que a thread1 foi executada primeiro, apesar de você ter colocado a prioridade para 4, porque a thread1 deu um start aqui, então a thread4, que era o bem-primil D, aparece aqui D algumas vezes em cima, mas não tem como garantir que essa vai ser a thread que vai ter a maior prioridade na execução, você só está indicando para o scheduler, na final das contas, depende da implementação da J3M da especificação, a maior das vezes essa prioridade não vai mudar muita coisa, então você não deve desenvolver seu código baseado nessa prioridade. E a segunda coisa que nós vamos falar é sobre o sleep, então, por exemplo, às vezes você quer utilizar uma thread, tipo assim, a thread está dentro de um loop, digamos que esse loop ele vai consultar um stock, ele consulta uma API a cada determinado momento, e você não quer que ele fique executando, então porque imagina, você coloca aqui um loop e eu gostaria que essa thread seja executada para fazer uma conexão em algum lugar, você não quer que a velocidade de processamento seja a velocidade que você vai atirar as conexões, então geralmente existe a possibilidade de você utilizar o thread.sleep, então como você pode ver o thread.sleep é um método estático, porque nenhum outro thread pode falar o thread2, você vai dormir agora, não, a thread2 mesmo que vai decidir que ela vai dormir, e o tempo aqui é em milisegundos, então se você falar assim, olha, dorme por 2 mil milisegundos, ou seja, 2 segundos, essa é uma das poucas coisas que é garantido acontecer, então aqui você pode ver que nós temos que tratar essa exceção, você não pode adicionar no método, porque a gente está sobrecarregando e não tem essa exceção lá, então o sleep precisa estar dentro de um track-cat, porque? Porque se ela não dormir os 2 segundos, você vai ter uma exceção, então é uma das poucas garantias que você tem no modo das threads, é que ela vai dormir por 2 segundos, você vai colocar thread.sleep em 2 segundos, e quando você executa esse método, você pode ver que eu estou aqui fora, estou dentro do for, mas fora do if, então quando executar agora com o 2510, você vai ver que a menha acabou, a gente executou aqui a t1, a t4, a t3, aí depois a thread-main acabou, porque todas elas estavam dormindo, ou seja, a thread-main estava disponível, botou ela para executada, e aí o que é interessante é que é o seguinte, você pode ver que basicamente está imprimindo de 4 em 4, 4 em 4 aqui, porque todas as threads, a t1, t2, t3, t4, quando chegam nessa linha 37, elas param por 2 milis segundos, então elas estão parando por 2 segundos, mas o negócio é, não tem garantia de que as threads vão continuar executando sequencialmente até chegar nessa linha 37, então por exemplo, o que acontece, você pode ter a thread-1 que executou esse C, a thread-1 pode parar, você pode ter a thread-2 que executou isso aqui, a thread-3, a thread-4, a thread-2 foi para cá, depois a thread-3, ou seja, a thread-1 que começou ainda nem chegou no método que faz ela dormir, então até chegar nesse método aqui, não tem garantia nenhum de que aqui começar, a thread-1 que começava e continuar até chegar aqui, então pode ser que a thread pare bem aqui nessa linha, e em seguida a outra thread comece a execução desse método, mas quando chega na linha 37, a thread vai dormir, então é isso que acontece, quando a thread dorme, você põe a thread para dormir, ela sai de running, ela vai para um estado de bloqueado e depois que ela termina o tempo que você determinou, ela volta para o estado de runnable, e do estado de runnable, a thread pode ser utilizada pelo scheduler para passar para o estado de running, então como você pode ver, ela vai ficar executando aqui de 2 em 2, 2 em 2, 2 em 2, e a gente ainda nem chegou no valor que a gente vai quebrar a linha, bom, então esse é o slip, uma das poucas garantias que você tem no Java, mas que ele vai fazer sua thread realmente esperar pelo tempo que você definiu aqui, bom, é isso aí galera, então vamos continuar com mais tópicos sobre a execução de threads na próxima aula, vejo vocês lá, até mais!

