 Olá pessoal, Fabio Akita. O tema do vídeo da semana passada é um buraco de coelho de Alice no País das Maravilhas. Eu estou demorando pra soltar vídeos porque cada assunto que eu esbarro eu vou pesquisar e abro mais uma dúzia de abas. Daqui a pouco eu vou enxerme os 32GB de RAM só de abas. Computação Retro é uma área gigantesca. Vocês não imaginam quantas comunidades existem, não só colecionando itens antigos, mas ainda desenvolvendo em assemble de MOS 6502 e outros processadores antigos como Z80, Intel 888 e isso só no mundo dos 8 bits. Se entrar em 16 bits vai cair em processadores com M5C816, do Super Nintendo e mais. Eu reescrevi o script de hoje várias vezes. Numa das versões eu estava gastando páginas e páginas só pra tentar explicar o problema da multiplicação em processadores antigos, mas ficou muito fora do escopo do canal. Só pra dar um gostinho, no último vídeo eu comecei a mostrar um pouco do assemble do MOS502 e algumas instruções básicas como LDA ou STA pra download no acumulador ou store do acumulador pra outro lugar. Avançando pra operações aritméticas, temos instruções como ADC ou SBC pra adição e subtração. Você já começaria coçando a cabeça quando precisasse somar números maiores que 255, que é o limite que cabe em 1 byte ou 8 bits. Lembra que o M5502 é um CPU de 8 bits? Então todas as instruções só conseguem trabalhar com 8 bits de uma só vez. Pra trabalhar com números maiores a gente particiona o número e calcula um pedaço de 1 byte de cada vez. Então vamos entender um pouco mais disso. Como todo mundo pelo menos já deve ter ouvido falar, chips como M5502 são feitos de componentes menores como um transistor. Um transistor em sua essência é um componente que funciona como um switch ou interruptor. Acho que essa é a imagem mais simples de ter na cabeça. Você pode comprar transistors individualmente empacotados como um componente mais fácil de manipular num protoboard como esse daqui. Aliás, no vídeo anterior eu chamei isso de breadboard, que é como falam nos Estados Unidos, mas aqui se chama protoboard. Enfim, usando transistors é possível criar alguns circuitos mais simples de todos. As portas lógicas que são peças fundamentais sobre as quais todo o resto é montado. Por exemplo, você pode montar uma porta lógica NOTE num protoboard com um transistor, um resistor, um LED pra ver a resposta, uma bateria e fios pra conectar. Uma porta NOTE quando você mandar zero ele responde 1, quando mandar 1 ele responde zero. Além de NOTE, podemos montar outras portas fundamentais como OR, AND, NAND, EXCLUSIVE OR DIAIANTE. E com essas portas podemos montar coisas mais complicadas como uma CPU inteira. Ou com outras construções como flip flops podemos montar memórias. E por aí vai. A primeira vista é difícil de entender como operações simples como inverter bits pode ser útil. Vamos pensar numa operação um pouco mais complicada que queremos ter numa CPU, por exemplo, somar dois números. Assumindo que todo mundo sabe somar, pensa em uma conta besta. Somar 28 mais 22. Você começa somando 8 com 2 vai dar 10. Coloca 0 embaixo e sobe 1. A mecânica interessante é que esse sobe 1. Agora, soma esse 1 que subiu com 2 do 28 e 2 do 22 e vai ter 50. E pra somar em binário é exatamente a mesma coisa. Pra converter o número decimal em binário você vai dividindo por 2. 28 por 2 é 14 e o resto é 0. 14 por 2 é 7 e o resto é 0. 7 por 2 é 3, o resto é 1. 3 por 2 é 1, o resto 1 fica 1, 1, 1, 0, 0. E pra ser 8 bits é só completar com os 3 zeros na esquerda. Fazendo a mesma coisa com 22 fica 0, 0, 0, 1, 0, 1, 1, 0. Números pequenos, mora você lembra de cabeça, mas pra números maiores, qualquer calculadora do Windows mesmo converte pra você. Ou em qualquer linguagem de programação tem uma função de formatar string onde você passa o inteiro e diz que quer formatar com base 2. Num JavaScript, basta chamar o método true string com argumento 2 no número. Pra somar esses dois binários, você começa da direita pra esquerda também. 0 mais 0 é 0, depois 0 e 1 é 1, 1 e 1 é 2, que em binário é 1, 0. Então coloca 0 e sobe 1. 1 mais 1 mais 0, mesma coisa coloca 0 e sobe mais 1. 1 mais 1 mais 1 é 3, coloca 1 e sobe 1. 1 mais 0 mais 0 é 1 e o resto é 0. Então o resultado final é 0, 0, 1, 1, 0, 0, 1, 0. Só parece difícil porque você não tá acostumado em enxergar 0s e 1s, mas a regra é a mesma e usa a mesma mecânica do sobe 1. A máquina de edição mais simples que soma dois bits é chamado de half other ou meio somador. Você liga uma porta end com uma porta xor e vai ter a soma e o carry bit. Carry é o bit onde grava o sobe 1. O meio somador vai fazer exatamente o que eu fui descrevindo até agora. Se passar 0 e 0 a soma é 0. Se passar 1 e 0 ou 0 e 1 é 1. Se passar 1 e 1 a soma é 2, então baixa 0 e sobe 1 pro carry bit. A versão completa se chama full adder ou somador completo. Um dos jeitos de montar um somador completo pode ser ligando duas portas xor, duas portas end e uma porta or. Ou melhor ainda, ligando dois meio somadores. A diferença é que além dos dois números pra somar, ele também recebe o carry bit de entrada e com isso pode cascatear múltiplos circuitos de somador completo um embaixo do outro, ligando que a carry bit de saída de um somador na entrada do outro. Se quisermos somar com números de 4 bits, adicionamos 4 somadores completos em cascata. Pra 8 bits precisamos de 8 somadores e com isso adquirimos um somador completo de 8 bits. Um circuito de somador completo pode ser montado de maneiras diferentes e com isso varia o número de transistors. Mas pense que na média vai ser alguma faixa de 10 transistors pra cada somador. Pra somar números de 8 bits vão precisar de no mínimo 80 transistors. Pra hoje em dia isso não parece grande coisa já que um processador A13 Bionic dos iPhone 11 Pro tem 10 bilhões de transistors. Um AMD Ryzen 7 3700X tem quase 6 bilhões de transistors e um AMD Epic ROMI que é pra servidores tem mais de 39 bilhões de transistors. Lembrando que são todos chips de 64 bits. Nosso pobrezinho MOS 6502 de 8 bits tem na faixa de 3.500 transistors. Lembre-se que estamos falando do meio dos anos 70. O que viemos fazendo depois, além de aumentar mais e mais a densidade de transistors por centímetro quadrado, foi adicionando novas funcionalidades como SIMD, que são instruções de single instruction multiple data pra a tela. Depois instruções de virtualização como VTX ou AMDV. Instruções pra criptografia como AES. Sem contar que os chips hoje são multi-core. Então é como se fossem múltiplas CPUs apertadas no mesmo chip. Mas as instruções fundamentais como soma bytes, carregar com mulador, incrementar contador de programa, atualizar pontador de pilha e coisas assim que vimos no Hello World da semana passada ainda é similar. Um primeiro insight é que os chips hoje são na ordem de 10 milhões de transistors mais densos que os chips dos anos 80 pra trás. Porém, isso não se traduz necessariamente em programas 10 milhões de vezes melhor. Pegue o melhor da geração 8 bits que foi Super Mario 3 e compare com o new Super Mario Bros rodando no Switch cujo SOC Tegra X1 tem na faixa de 7 bilhões de transistors com 4 cores ARM Cortex A57 ativos. Vamos descer um pouco mais hardcore pra ver o contexto com o tipo de CPU que estamos trabalhando. A adição eu disse que fazemos mais ou menos no mesmo jeito que você faria no papel, somando dígito a dígito e subindo um quando precisa. Se hoje em dia temos transistors de sobra na CPUs, nos 3.500 que tinha no MEA502 cada transistor contava. Então só era implementado o estritamente necessário. O somador completo numa cadeia de 8 bits está implementado na instrução ADC. Se recapitularmos sobre o pouco que aprendemos sobre o nível do MEA502 pra realizar uma adição de números de 8 bits, faz de conta o número 1 mais 2 poderíamos fazer assim. Começa com o load do número 1 no acumulador, ADC que é a adição com carry onde passamos 2 e ele vai somar com o número 1 que já estava no acumulador, da ARM Azena ou Store do resultado que fica no A pra algum endereço na memória como o endereço 600 que no vídeo anterior ia mandar pro chip de trava e de lá pro LCD. Isso é uma coisa que hoje em dia você não se coloca porque as linguagens de programação já cuidam disso. Mas o MEA502 faz calvos com números de 8 bits e o valor máximo que cabe em 8 bits sem sinal é FF255. O que acontece se eu tentar somar 255 mais 255? Precisamos de mais bits. Só porque uma CPU é de 8 bits não quer dizer que não podemos calcular números maiores, mas pra fazer isso precisamos particionar o número e lidar com pedaços dele. Por exemplo, digamos que tivesse uma CPU decimal mas que só faz conta com números de 2 dígitos de cada vez, então de 0 até 99. Se somarmos 99 mais 5 a gente ia ter 104. Precisaríamos gravar um 1 separado do 04. No caso da Soma eu disse que todo somador completo lida com 1 bit do número. A instrução ADC é como se fossem 8 somadores completos em cadeia pra 8 bits. Uma nomenclatura que às vezes você vai esbarrar é High Order e Low Order. Quando lidamos com 16 bits é 2 bytes. O primeiro byte à esquerda chamamos de High Byte e o último à direita de Low Byte. Dentro de cada byte tem 8 bits e o bit mais à esquerda é o MSB ou Most Significante Bit e o último bit é o LSB ou List Significante Bit. Literalmente bit mais significativo e menos significativo. Lembra quando eu expliquei sobre Little Engine no episódio anterior é pegar os bytes e inverter, assim o Low Byte é lido antes do High Byte. Voltando pra Soma, toda vez que tiver um Sob 1 ele vai ser gravado no registrador C. Antes de toda Soma o certo é usar instrução CLC, literalmente Clear C pra limpar esse registrador, mas podemos não limpar também. Lembra que falei que registradores funcionam como variáveis globais? Várias instruções deixam efeitos colaterais pra cada byte, deixando registradores com a sobra do que foi processado. E podemos usar isso a nosso favor. Começar somando a primeira metade número até 8 bits e depois somar a segunda metade que vai usar o carry do C e continuar a Soma com o resto dos bits. Por exemplo, digamos que temos um número grande de 24 bits tipo número 2 milhões. Seriam 3 pedaços de 8 bits, cada um que a gente pode usar o High, Medium e Low Byte. Declaramos então os 3 pedaços do primeiro número A como A, High, A, Mid e A Low. Depois B, High, B, Mid e B Low. Começamos limpando o registrador C, fazemos a Soma dos bytes Low que é da Low de no A Low, adicionar com B Low e guardar esse resultado parcial em B Low, depois a mesma coisa com os bytes Medium e High. A Soma final é a junção dos 3 pedaços de B. Pense na sua linguagem favorita, você nunca se preocupa com isso, simplesmente escreveria A mais B. Como você tem processamento e memória de sobra e seus programas nunca são particularmente complicados, mesmo que tenha desperdícios não chega a ser um problema, mas como seus recursos são extremamente limitados desperdiçar bits é um problema real, desperdiçar ciclos também porque cada instrução gasta alguns ciclos de clock. Nada sai de graça. Um processador moderno roda na faixa de 2 GHz a 5 GHz hoje em dia, mais um 6502 roda entre 1 a 3 MHz. Portanto, em máquinas pequenas como 6502 queremos tanto economizar a quantidade de memória usada quanto o número de instruções pra não desperdiçar clocks. Literalmente podemos fazer dezenas de milhões de instruções a menos por segundo no 6502 do que num processador moderno de qualquer smartphone hoje. Fazer programas simples num computador excessivamente poderoso é muito fácil, qualquer um faz. Eu sempre digo que você sabe quando um programador é bom quando ele consegue programar num sistema com restrições porque a arte de programar é conseguir tirar o máximo que o hardware oferece. Vamos dar outro exemplo besta. Já sabemos como CPUs fazem adição. Subtração e multiplicação é a mesma coisa, podemos desenhar circuitos como no caso do somador completo e implementar com transistors. Como eu falei antes no 6502 temos a instrução ADC pra adição e também temos SBC pra subtração mas não tem multiplicação. Digamos que você, que nunca estudou nada de engenharia ou ciência da computação, pense numa forma de implementar multiplicação só usando operações básicas que falamos até agora como o adição. O que você faria? Eu aposto como a solução mais imediata que a maioria pensaria seria via adições sucessivas. Por exemplo, se você fosse multiplicado 178 vezes 7 você ia somando 178 7 vezes até dar 1148. Seriam só 7 adições e não parece tão ruim assim, aquele famoso caso de a testei aqui no meu computador funciona. Mas e se quisermos multiplicar 10.000 vezes 10.000? Agora precisa fazer 10.000 somas pra chegar no resultado. Isso é consideravelmente mais devagar e com números maiores só vai piorando. Vamos usar um hipotético só pra ilustrar. Pra somar cada bloco de 8 bits digamos que precisaríamos gastar uma instrução de load, uma de ADC e outra de store. Cada um custando uns 5 ciclos de clock. 10.000 é o número que podemos representar em 2 bytes ou 16 bits, então são pelo menos 2 loads, 2 ADCs e 2 stores pra cada rodada. Então temos 6 instruções custando uma média de 5 ciclos de clock, ou seja, 1 ciclos em 1 MHz podemos ter no máximo umas 33.000 sequências dessas por segundo. Mas se precisamos executar 10.000 sequências de soma dessas gastaríamos 1 terço de segundo ou pelo menos 300 milisegundos. Lembrando que eu tô considerando condições ideais de temperatura e pressão como a gente falava no colégio, mas provavelmente gastaria mais ciclos do que isso. Parece pouca coisa mas 300 milisegundos é mais tempo que leva pra você pedir uma página num site, ele processar, retornar o HTML e só renderizar. Aliás, se sua aplicação demora 300 milisegundos pra responder e ser considerado lento quase parando. Pra variar, não existe uma fórmula universal de multiplicação que tem 100% de melhor performance pra todos os casos. O bom senso é o contrário. Fórmulas universais costumam ser lentas. Isso é uma coisa que como programador você precisa entender. Existem fórmulas que funcionam melhor pra casos diferentes. Por exemplo, no episódio anterior eu já disse como faz multiplicação de fórmulas, basta fazer um shift left que é o equivalente a adicionar um zero no final do binário, pronto, tá multiplicado uma única instrução. Se você procurar, existem alguns algoritmos simples de multiplicação que você encontra na internet e eles não são tão bons gastando uns 100 ciclos cada um. Se seu programa for ter poucas multiplicações pode ser suficiente, mas qualquer operação que gasta mais que 100 ciclos num 6502 não é exatamente rápido. Existem maneiras mais rápidas que isso aqui vem outro em site e como programador você precisa ter na cabeça. Algoritmos costumam ser um balanço de dois fatores. Se você quiser economizar memória vai acabar gastando mais ciclos de processamento. Se quiser velocidade economizando ciclos provavelmente vai gastar mais memória. Por exemplo, vamos pensar um pouco mais como você faria multiplicações rápido no primário sem calculadora. Pra números pequenos você provavelmente teria que ter decorado a tabuada. Lembram disso? Eu tenho certeza que a maioria odiava ter que decorar a tabuada. Mas lembre de uma coisa, a tabuada é uma tabela pré-calculada. Você procura o multiplicando e o multiplicador e instantaneamente tem a resposta. Imagine uma tabela pré-calculada pra todos os números que cabem em 8 bits. Daí basta achar a posição na matriz com o resultado direto. Você vai gastar ciclos pra pré-calcular a tabela da primeira vez ou pode ler direto a tabela de uma segunda vez. O problema dessa solução é que fácil fácil ela vai ocupar 16 kilobytes de espaço ou mais. Considerando que um Super Mario Bros inteiro cabe em 40 kilobytes, estamos falando em gastar 1 terço disso, só numa tabela de números, o que seria um enorme desperdício. Uma tabela pré-calculada é o que chamamos de Lookup Table. E isso é uma técnica usada em todos os lugares da computação. Você que faz desenvolvimento web provavelmente já usou ou vai usar isso. Por exemplo, quando faz cache com um Redis ou main cache é um Lookup Table. Quando cria índices numa tabela de banco de dados isso é um tipo de Lookup Table. O problema é que se essa tabela for grande demais, o tempo pra procurar na tabela também pode começar a ser um problema. Fora desperdício de espaço caso você não planeje direito. Mas como seria uma maneira melhor então? E aqui a matemática nos ajuda. Se você estudou a álgebra ou trigonometria, não vai achar estranho se você quiser seguir. Uma multiplicação de dois fatores, A e B, pode ser descrita de maneiras diferentes. Por exemplo, ela pode ser a exponencial da soma dos logaritmos de A e B. Se quiser ser mais complicado pode ser a soma do cosseno de x mais y com o cosseno de x menos y, tudo dividido por 2 sendo que x é o arco-cosseno de A, que também é chamado de cosseno inverso. E arco-cosseno é usado pra determinar o ângulo do cosseno em radianos e y da mesma forma é o cosseno de B. Continuando, A vezes B pode ser também o quadrado de A mais B menos o quadrado de A menos o quadrado de B, tudo dividido por 2. Ou finalmente pode ser o quadrado de A mais B menos o quadrado de A menos B, tudo dividido por 4. E essa opção final é que nos interessa, pois podemos reduzir a fórmula pra ser a subtração de A mais B aplicada numa função F com A menos B na mesma função F sendo essa função o quadrado do número que passarmos dividido por 4. A parte importante é que decompomos o problema da multiplicação numa adição dos fatores, subtração dos fatores e subtração do resultado da tal função F. E a adição e subtração são instruções que a gente tem no assemble. E essa função reduz o tamanho do lookup table pra em vez de ser todos possíveis resultados da multiplicação de todos os números de 8 bits, vamos ter simplesmente uma tabela só com o resultado da multiplicação do quadrado dos números, ou seja, de 1 vezes 1 de 2 vezes 2 de 3 vezes 3, assim por diante, que é uma quantidade precalculada, ordens de grandeza menor caindo dos 16 kilobytes que eu falei antes pra talvez meio kilobytes. E pra calcular, o quadrado de todos os números também vai ser rápido, porque existe a propriedade que o quadrado do número é o quadrado do número anterior mais um número ímpar, então o quadrado é 0 mais 1, o quadrado de 2 é o 1 anterior, mas o próximo ímpar que é 3, resultado 4. O quadrado de 3 é 4, que foi anterior, mais o próximo ímpar 5 que dá 9. O quadrado de 4 é o 9, mais o ímpar 7 que dá 16. O quadrado de 5 é 16, mas o próximo ímpar 9 que dá 25 e assim por diante. Então reduzimos tudo pra somas. E como eu disse no começo, dá pra ir longe estudando sobre assemble. Outros assuntos que eu tava pensando em cobrir nesse episódio incluíam o conceito de complementar de dois números inteiros com sinal pra lidar com negativos, algoritmo de buff pra multiplicação e muito mais, mas é teoria de mais pra um único vídeo. Então por hoje eu vou parar por aqui. Mas eu queria gastar pelo menos um pouco de tempo mostrando essa linha de raciocínio pra vocês entenderem que não, hoje em dia você dificilmente vai gastar tempo implementando uma multiplicação na mão. Toda a CPU já implementa as melhores fórmulas em hardware e pra quem precisa de casos específicos existem bibliotecas voltadas pro campo científico que otimizam os piores casos. Mas é importante você entender que tudo que uma linguagem te oferece, cada pequena coisinha insignificante como aquele mero asterisco de multiplicação teve milhares de horas homem de pesquisa, experimentação, otimizações, literalmente muitos suor e lágrimas, até chegar no estado da arte que você usa hoje sem nem pensar. É isso que significa subir nos ombros de gigantes, porque é com o conhecimento testado e acumulado de centenas de anos de matemática que esse asterisco de multiplicação se tornou possível e você consegue multiplicar dois números de praticamente qualquer tamanho em microsegundos. E também é pra entender que muita coisa hoje ainda não tem fórmula perfeita. Eu disse que temos CPUs com dezenas de milhões de vezes mais transistors que um 6502, mas ainda assim não tem os programas dezenas de milhões de vezes melhor. Isso porque muitas partes do software que usamos ainda não tá rodando a melhor forma possível. Grande parte do que é o trabalho de um programador é não ignorar os problemas e parar pra tentar encontrar formas mais inteligentes de fazer o computador processar. Muito bem, vamos voltar ao nosso nintendinho. Assim como no exemplo do protoboard do Ben Itter, o PCB que é sigla pra printed circuit board ou placa de circuito em preço contém o cérebro que é o 6502 e diversos outros chips, como chip de RAM, chip de VRAM que é memória de vídeo e outros componentes como pra ligar seus controles. Tem a PPU que é o Picture Processing Unit ou unidade de processamento de imagens, que é a versão primitiva do que hoje você chamaria de GPU. E tem a APU ou Audio Processing Unit pra gerar som. O nintendinho já foi tão dessecado nas últimas décadas que temos documentação super completa de cada componente em detalhes suficientes pra ter muita gente fabricando chips e PCBs novos. Você consegue literalmente comprar um hardware moderno de nintendinho hoje, se quiser, e ele vai ser 100% compatível com qualquer cartucho que você tenha guardado. Mas por que me interessa a documentação é tão boa que é possível criar emuladores em software que se comportam exatamente como hardware? Eu não sei se vocês conseguem entender a beleza disso, todo hardware tem a capacidade de simular o comportamento de outro hardware via software e praticamente toda a linguagem de programação consegue representar qualquer hardware. Tendo documentação tão completa como o weakness dev, poderíamos escrever nosso próprio emulador. E como alguém faz isso? É um processo mais trabalhoso do que difícil porque você precisa ter o trabalho meticuloso de implementar cada detalhe que está nas documentações. Mas, por exemplo, podemos começar criando um projeto vazio, digamos usando a linguagem Go. E, aliás, como nintendinho é bem antigo, qualquer linguagem hoje consegue simular o Mea502 e os outros componentes. Não existe o jeito correto de se escrever um software. Se você pegar diferentes emuladores de nintendinho, vai ver que eles são organizados e escritos de maneiras diferentes. Só com experiência e muitos testes você vai chegar no que é o melhor balanço entre legibilidade e eficiência. Mas pra ser simples, podemos pensar nos componentes principais que eu listei. O primeiro elemento que queremos emular é o console propriamente dito. Então começamos criando um arquivo chamado console.go. E dentro definimos o tipo console como uma estrutura. E não se preocupe se você nunca viu o Go. Não é relevante entender cada linha do código hoje, só o raciocinho. Estude depois com calma. Essa estrutura vai declarar ponteiros pra CPU, pra APU, pra PPU, pra cartucho, pros dois controles pra um troço que eu vou explicar depois chamado mapper e delimitamos a RAM, que é só um array. Lembram todos aqueles hexadecimais que eu falei no vídeo anterior? Pense nesses números como oposições no array. Memória é isso, uma listona de bytes. Agora precisamos criar arquivos pra cada um desses componentes e definir as estruturas de cada um. E o próximo é o arquivo CPU.go. A estrutura CPU vai ter muitos dos elementos que eu expliquei no vídeo anterior. Começamos definindo uma referência pra uma estrutura de memória que vou explicar depois. Daí definimos PC que é o apontador de programa como inteiro. Vamos definir o SP que é o apontador de pilha. Daí os registradores todos de 8 bits, ou seja, um byte. Temos o acumulador A, X, Y, C, Z, I, D, B, U, V, N. E por fim temos uma última estrutura importante, um array de instruções. Lembra que cada instrução como LDA tem um hexadecimal associado que é basicamente o endereço da localização dessa instrução? Pois é, precisamos colocar cada opcode na posição correta nessa lista. Quando quisermos achar instrução A9, que é o LDA, vamos pra posição A9, que é a posição 1,5, A9 nessa lista. Daí vamos encontrar a referência pra uma função de Go. E agora precisamos implementar cada uma dessas funções. Por exemplo, o nosso LDA sabemos que vai escrever o valor no registrador A, que é o acumulador. Então em Go é simplesmente associar o valor do argumento na variável A da CPU. Sabemos também que JSR é o jump pra uma subrotina. O que ele faz é empurrar o endereço no contador de programas pra pilha e sobrescrever o endereço de programa com o endereço da subrotina pra onde tem que pular. E assim vai, tem que escrever uma função pra cada instrução que existe de acordo com a especificação na documentação do 6502. Uma vez feito tudo isso, podemos criar o inicializador Neo CPU que vai alocar a estrutura que definimos. Esse inicializador recebe uma referência pra estrutura de console que criamos antes pra passar pra essa nova estrutura chamada memory. Deixa esse memory de lado que ainda não é hora pra ele. E em seguida criamos e populamos a tal tabela com referências pras instruções que criamos. E finalmente criamos uma rotina de reset. Reset é o que você pensou mesmo. O equivalente a você apertar o botão reset que todo console e computador tem. A ideia é limpar o contador de programas pra apontar pro endereço FFFC. Lembra do episódio anterior que quando o 6502 inicializa, a primeira coisa que ele faz é ir no endereço FFFC, procurar a primeira instrução do programa? Pois é. E em seguida, limpamos o apontador de pilha pra iniciar em FD. Isso é pra relembrar a importância desses dois registradores, porque é com eles que conseguimos executar um programa. Tem mais coisas que precisam ser feitas pra CPU ficar completa, mas por agora, vamos pular pra essa tal de memory, criando um arquivo memory.go. A estrutura em si é muito simples, ela só vai apontar pra uma referência à estrutura de console que já definimos antes. A parte importante começa com a função de leitura read. Ele recebe um endereço e vai devolver algum valor que teoricamente está em algum lugar na tal memória. E aqui começa a diferença de um nintendinho e outros computadores que usam o processador 6502 como um Atari ou Apple II, o mapa de memória. No episódio anterior, eu expliquei que temos endereços de 16 bits, então podemos mapear do endereço 0000 até FFFF e daí dividimos esse espaço e por exemplo a CPU ia procurar no EPROM se passassemos endereços acima de 80000, ou seja, arbitrariamente definimos que certos chips respondem a certos endereços. A grosso modo do endereço 0000 até 07FF temos 2kB de RAM. Nos endereços 0000 a 007, que é bem curto, temos registradores pra PPU. De 40000 a 4017 acessamos a APU e registradores de IOU como os controles e só de 80000 FFFF. Temos equivalente a uns 32kB reservados pra endereços que mapeem pra algum lugar do cartucho. Em particular se acessarmos acima do endereço 60000 temos esse negócio que colocamos no código chamado Mapper e agora vocês precisam entender os truques que eram usados em consoles com cartuchos. Se sua história com games começa só depois do Playstation 1 você tá acostumado a ter os games em CDs, DVDs, Blu-rays ou instalados no HD do seu computador. É de praxa que toda vez tem que esperar o famoso loading, que é o tempo do computador começar a carregar os primeiros bytes do jogo na RAM pra só depois conseguir começar a jogar. Daí a cada fase tem que carregar novos bytes pra RAM e jogar fora os bytes da fase anterior que não vai precisar mais. Isso é necessário porque não cabe todo o jogo na memória. Um computador muito bom hoje tem 16gb mas qualquer jogo moderno tem 30gb, 40gb, alguns jogos podem ter absurdos 100gb. Obviamente não cabe tudo na RAM então precisa ir carregando e descarregando de pedaço em pedaço. Com cartuchos é diferente, o que tem em cartuchos são chips de home, como expliquei no episódio anterior. Então quando você pluga o cartucho no console não existe loading, não tem que carregar nada e ele pode iniciar imediatamente porque a CPU acessa os endereços diretamente da RAM sem precisar carregar o jogo em memória. O cartucho é a memória, vocês entenderam? Diferente de CD ou HD, a ROM do cartucho já tem velocidade máxima de acesso igual da RAM. Da mesma forma que a CPU consultaria o endereço na RAM, no caso pedindo endereços 0.0.0.0.0.7.ff, quando ele precisa de dados do jogo ele perde uns endereços acima de 8.0.0.0 até ffff. Por isso jogos de consoles antigos carregam instantaneamente e não tem loading entre fase e tudo é rápido. Um dos maiores gargalos ainda não resolvidos em games modernos de fato é a lentidão do I.O. não só do HD mas de toda a cadeia de dados, incluindo barramento, controlador e tudo mais. E inclusive é isso que a nova geração de consoles PS5 e Xbox Series X estão tentando combater, colocando os SSDs e controladores mais rápidos do mercado pra minimizar o máximo tempo de carregar coisas do disco. Mesmo assim o tempo nunca vai ser zero como era nos cartuchos. Eu vou repetir o que eu disse antes. Programação é sempre um trade-off, uma troca. Cartuchos tem tempo quase zero de acesso porque ele é direto um chip de memória. O problema é que chips de ROM são muito mais caros de produzir comparado a discos de HD ou Blu-rays, é bem mais caro. A comparação mais óbvia foi na transição dos cartuchos pro CD quando saiu o Playstation 1 e o concorrente na época era o Nintendo 64, que preferia usar cartuchos pelas razões que eu acabei de falar. Jogos de Playstation podia ter vídeos e muito mais conteúdo porque num CD daquela época era possível já colocar 650 megabytes de cartuchos. Em comparação, um dos maiores cartuchos do Nintendo 64 era o Conker's Bad for Day, que tinha enorme 60 megabytes, ou seja, mais de 10 vezes menos espaço e o cartucho ainda custava mais caro. Os lendários Zelda, Ocarina of Time e Majora's Mask eram cartuchos de menos de 30 megabytes. Por isso jogos de Nintendo 64 raramente tinham algum vídeo e também por isso também preferiam usar o cartucho de texturas dos modelos em 3D porque texturas são imagens bitmap que consomem muito espaço. Voltando pra era dos 8 bits, um cartucho como do Super Mario original tem 40 kilobytes, portanto Malemali encaixa no nosso espaço de endereços reservados pra home. Mas um Super Mario 3 tem 385 kilobytes, quase 10 vezes mais bytes que o original. Um dos jogos mais pesados no cartuchinho é o Kirby's Adventure e se você rodar vai ver um dos games mais bem elaborados pro nintendinho, chegando perto de um jogo de Super Nintendo. E também puder. O cartucho dele tem quase 800 kilobytes, perto de 1 mega. Mas como é possível endereçar isso tudo de bytes só com endereços de 16 bits? E agora vem o segundo grande fato sobre cartuchos. Eles não têm só chips de home. Na realidade, um cartucho é uma placa de expansão, um PCB completo. Quando falo em placa, é mais ou menos como quando você compra uma placa gráfica como um novo NVIDIA RTX e espeta no slot PCIe Express na placa mãe do seu computador. Encaixar um cartucho no console é a mesma coisa. Num PCB, você pode plugar não só home como qualquer outro componente. Por exemplo, você pode colocar um chip de S-HUN e uma bateria de lithium e boom, você acabou de ganhar a capacidade de salvar o jogo. Só que isso torna o cartucho ainda mais caro. Por isso nem todo jogo podia salvar. Um dos chips mais famosos se você jogou Super Nintendo foi o chip Super FX, que literalmente era uma placa primitiva 3D que permitiu jogos como Star Fox. O processo é o mesmo. O chip vem no PCB do cartucho. Você literalmente podia enfiar um nintendinho inteiro dentro de um cartucho, mas só isso não responde à pergunta de como fazia pra um Kirby ter quase 1 mega de dados. Não basta só enfiar mais chips de home se não temos endereços suficientes pra passar de 32 bytes. Endereços funcionam como o nome diz. É como se tivéssemos uma rua de casas e só tivesse 32 números. Da casa 33 em diante ficaria sem número. Se o carteiro precisasse entregar alguma coisa nessas casas, como ele encontraria? E se nessa casa colocássemos um síndico que separasse a rua em blocos? Daí teria casa de 1 a 32 no bloco A, casa de 1 a 32 no bloco B e assim por diante. Continua só tendo 32 números, mas dependendo do bloco sempre encontraríamos uma coisa diferente. E é exatamente isso que o nintendinho faz. No cartucho, além de vir mais home, ele vem com um síndico, um controlador que chamamos de mapper. Como o nome diz, mapper é um mapeador. Em vez de blocos na rua do nosso exemplo, a memória home é dividida em banks ou bancos. E a técnica pra enxergar mais memória se chama bank switching. A CPU continua só conseguindo enxergar os recursos 8.0.0.0 a FFFF, mas ele pode pedir pro mapper trocar os banks, assim como no nosso exemplo da rua. Os banks costumam ter 16 kilobytes de tamanho e podemos ter vários banks, então se montarmos o cartucho com ROM suficiente pra 50 banks de 16 kilobytes, vamos ter os 800 kilobytes do jogo do Kirby. Agora vem a parte cabeluda pra fazer emulador de NES. Não basta só ter código que representa o console, precisa também emular os chips que vem nos cartuchos, em particular esses mappers. Você poderia imaginar que deve ter alguns poucos modelos de mappers, mas que nada, se olhar a biblioteca toda de games de nintendinho, existem 407 mappers que foram encontrados e documentados. Por sorte se você cobrir os mappers da própria Nintendo e alguns de marcas famosas como Konami já cobre a maior parte dos jogos. Muitos mappers só existem jogos escuros, feitos na China ou lugares assim. Se você olhar de novo no wikidanesdev vai encontrar o código que vem no cartucho que identifica qual mapper ele tem. No arquivo de memory ele vai selecionar um mapper baseado nesse código identificador que lê da ROM. Daí precisamos de cada um dos mappers que precisam responder as mesmas funções e por isso no nosso arquivo de mapper vamos definir uma interface que todos os mappers vão ter que implementar. Basicamente definimos o que o mapper obrigatoriamente fazer que é ler da ROM, gravar na RAM e coisas assim. No inicializador pegamos o cartucho associado no console. Depois que carregarmos o marrom ele vai preencher esse campo mapper com seu código identificador e com isso podemos checar qual mapper vamos ter que carregar. Nesse pequeno emulador em Go vai ter só alguns dos principais. De curiosidade esse último mapper código 225 é que permite aqueles cartuchos de 52 jogos em um que você já deve ter visto por aí. Um dos desses tinha 6 chips de ROM com meio megabyte cada. Eu não vou entrar no detalhe de cada um, senão a gente vai ficar aqui até o ano que vem. Mas só pra mostrar um podemos criar um arquivo pro mapper 2. Lembrando que no nosso caso usando máquinas modernas não temos esses limites pequenos de 16 bits. Podemos carregar a ROM de um cartucho inteiro como uma reisão contínuo de bytes, seja lá quanto os bytes tiver porque temos espaço pra mapear tudo. Então recebemos o endereço que manda e mapeamos com esse reisão. No caso que nos interessa é que quando carregamos a ROM os bytes são identificados como regiões distintas sendo as duas principais o prg e chr. Prg são bytes de programa e chr são os bytes de caracteres que é a área onde normalmente estão os tiles. Eu sempre chamo de tiles mas se for traduzir é como se fossem azulejos. Tiles, azulejos, caracteres são termos que significam a mesma coisa. O princípio de tiles é simples. Um CPU com o mea 5.0.2 não fica dando instruções pra escrever pixel a pixel na tela. Ele pede pra escrever tiles. Pense no nintendinho como editor de texto. Um editor não escreve pixel a pixel na tela. Ele escolhe uma letra de alguma família de fontes, digamos, arial e passa o código que representa ela. E o Windows, ou macOS da vida, é que vai se encarregar de realmente desenhar os pixels. No nintendinho, quem se encarrega de desenhar os pixels é o chip chamado de PPU que eu falei que é a unidade de processamento de pixels. O CPU não entende pixels, ele entende tiles. Significa que o PPU tem que trabalhar bastante pra desenhar pixel a pixel. Inclusive o clock do PPU é maior que do CPU, mas a CPU só precisa mandar um byte pra identificar blocos de 8x8 pixels de uma só vez, em vez de mandar 64 comandos dependentes pra cada um desses pixels. Se você é de web, front-end, já lidou com algo assim. É como os sprites de CSS. Aliás, a técnica de sprites de CSS não é novidade, isso é uma técnica antiga. Outra técnica antiga são fontes com imagens, como a font Awesome, que todo o site hoje usa pra desenhar ícones. A memória CHR da ROM que eu falei é como se fosse uma fonte Awesome, literalmente caracteres. E cada caracter ou fonte é um tile. Acho que assim vocês conseguem visualizar na cabeça. Com sólis antigos assim, sequer tem fontes ou tabela de letras, cada jogo define suas fontes e o código das letras, porque não tem um padrão como ASC ou Unicode. A PPU enxerga resolução máxima de 256 por 240 pixels, e a CPU só enxerga uma grade de 16 por 15 espaços onde cabem os tiles. É parecido com o computador DOS antigo, que tem resolução de 640 por 480, mas em modo texto, só enxerga 80 colunas por 25 linhas de texto. O PPU também só consegue enxergar 8 kilobytes de tiles de cada vez, então toda vez que precisamos de mais tiles, o CPU pede pro mapper trocar o banco por outro. Existem dois excelentes emuladores pra quem quer aprender a programar jogos de verdade de Nintendo, e um deles é o FCEUX, que acho que é o mais conhecido, e o outro é o MESEN, que eu acho que tem ferramentas mais modernas. Vocês entenderam o que eu fiz até agora no código? Eu fui estruturando um tendinho como código de Go. Cada aspecto deles são estruturas de dados normais, como arrays e bytes. Bites na memória que sabemos exatamente onde estão, e com isso podemos consultar a qualquer momento. Seja o emulador feito em Go, em C, C++ vai ser a mesma coisa. O emulador MESEN implementa de forma parecida, mas além de só emular, ele expõe essas estruturas de forma visual em tempo de tempo. Por exemplo, podemos abrir um visualizador da memória da PPU e organizar pra vermos os bitmaps. E olha só o que tem na memória da PPU. Esses são os tiles. Cada tile é um quadrado de 8x8 pixels. Se eu não estou enganado, podemos associar até quatro cores pra cada um, dentre 12 cores de uma paleta, num total de quatro paletas que eu posso escolher. Em outra aba, podemos ver as 12 cores da PPU, e outras 12 cores da paleta dos Sprites. Se você já brincou de front-end, HTML, CSS, certamente já viu código de cores em hexadecimal e é a mesma coisa. Como a localização dessa área, CHR na ROM é conhecida, podemos editar o que tem lá. Os tiles são bitmaps não comprimidos, e hoje em dia você está acostumado a lidar com imagens comprimidas, como o JPEG, que usa um mesmo loss, ou seja, que perde detalhes da imagem pra reduzir o tamanho. Um bitmap, exatamente o nome diz, um mapa de bits, nas posições exatas pra formar a imagem e sem compressão. Só pra mostrar como podemos afetar o jogo, como o Mezen rodando, podemos editar as cores da paleta de background e trocar a cor do céu, por exemplo, pra outra cor, ou podemos mexer na paleta de Sprites e trocar a cor do Mario. Você pode mudar completamente a aparência do jogo, só de editar as cores dessa forma. Repetindo, pense na tabela de tiles como se fosse uma tabela de fontes de letras. Aliás, o nintendinho sequer tem fontes, ele não tem um sistema operacional, o jogo começa rodando direto no hardware, sem nenhuma camada intermediária pra ajudar. Então, se um jogo quer escrever textos na tela, ele próprio precisa embuti tiles de fontes. E de fato você vai ver que normalmente começando no endereço zero dessa área CHR, costuma ter letras, e símbolos. E aqui o número zero é a posição zero mesmo, o número um é a posição um e assim por diante. E começando do zero, a ta letra F fica bonitinho de zero a F em hexadecimal. Lembra quando usamos no Linux a ferramenta Hex Dump ou XXD e na terceira coluna ele tenta interpretar bytes que mapeiam pra tabela ASC como letras e às vezes aparecem textos mesmo? Numa hond video game isso não funciona porque os códigos das letras não seguem a tabela ASC, mesmo entre jogos diferentes a posição das letras na ROM não é a mesma. Por isso em emuladores com debug como o mesm e fcux podemos carregar nossa própria tabela que mapeia código das posições das tiles pras letras, como essa na tela que é um arquivo texto com extensão TBL, assim podemos tentar reconhecer algum texto no meio do binário. Veja no espaço prg da ROM que não dá pra identificar nada, mas carregando a tabela começamos a reconhecer quais bytes são textos e com isso podemos editar o texto, por exemplo trocando de Mario pra Fábio. Resetamos o jogo e olha só como aparece meu nome. Podemos trocar todos os textos num cartucho e salvar o binário por cima, contando que o texto novo caiba no mesmo espaço usado pelo texto antigo. Esse é o hacking mais simples de todos, que todo mundo que já brincou com binários já fez na vida. É assim que muita gente traduziu cartuchos japoneses pra inglês por exemplo. Se tiver filhos pequenos eu imagino que eles vão gostar de ver os nomes deles nos jogos. E podemos editar o binário não só do texto como dos tiles, por exemplo. Existem programas como Tile Layer Pro. Se abrirmos a ROM do Super Mario no começo vamos ver um monte de sujeira que são bytes de programa, mas se descermos vamos encontrar os tiles do jogo. Pra enxergar melhor podemos mudar a paleta e rapidamente vamos começar a reconhecer alguns como os tiles que formam o personagem. Pra ver melhor podemos arrastar os tiles pra essa outra janela e montar como um quebra cabeça. O Mario grande é formado por 6 tiles e na ROM tem a sequência pra cada posição de animação seja correndo ou pulando. Podemos fazer mais, podemos editar cada tile e mudar o jogo completamente. É um puta trampa editar tile a tile, mas se tiver paciência fazendo isso eu podia pegar os bits de tiles de um Zelda ou mega man e mudar o Mario pra ser o Link ou qualquer outro personagem que caiba em 6 tiles ou menos. E só com as técnicas que eu mostrei aqui você podia fazer um jogo novo usando um que já existe como base. E sabe quem já fez isso? A Tech Toy aqui no Brasil. Por causa deles nós somos o único país no mundo que ainda produz Master System novo até hoje. O Master System foi o concorrente do nintendinho nos anos 80. Também é um console de 8 bits mas no papel ele era tecnicamente superior. Em vez do 6502 de 1.8 MHz o Master System vinha com os Z-LOG Z80 aqui até 3.5 MHz. Quase o dobro
