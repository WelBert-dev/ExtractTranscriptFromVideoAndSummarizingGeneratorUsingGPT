 E aproveitando que eu comecei a falar de projetos open source do twitter, na parte do paper onde ele explica o desenvolvimento da solução graphjet, eu falei que tem uma sessão que fala da estratégia de IDIS. Isso gerou outro projeto open source chamado Snowflake, que eu não conhecia também, mas em dados distribuídos, IDIS únicos é um problema. Por exemplo, numa tabela de banco de dados mais sico rodando na sua máquina você coloca um inteiro auto incremental e esquece. Cada nova linha vai ganhando um ID como 1, 2, 3, 10, 11, 12, 1, 1, 1 e 2 e assim por diante. Os IDIS incrementais tem diversos problemas, um deles é segurança, mas o outro é conseguir particionar esses IDIS. E quando eu tenho um banco de dados distribuído em dois servidores, eu vou só dizer que no primeiro servidor vai de 1 a 1 milhão, no segundo servidor vai de 1 milhão a 2 milhão, isso não escala, se você for mais esperto vai lembrar. Ah, podemos usar coisas como UID ou GUID da Microsoft, IDIS de 64 bits ou 128 bits aleatórios, ou até espaços menores, de 48 bits como MAC address de placas de rede. Quanto maior o ID, mais espaço vai ocupar em disco e quando carregar em memória. E se vamos desperdiçar esse espaço, o ideal é que não seja aleatório e sirva algum propósito. Daí temos IDIS semi-aleatórios, no caso da estratégia do Snowflake, o ID é um número aleatório pré fixado com o timestamp, um identificador do servidor onde está e uma sequência numérica aleatória. E dessa forma eu consigo agrupar tweets que foram criados num determinado período de tempo e eu tenho a localização no cluster de servidores, mas eu também sei que não vai ter colisão desse ID com outro ID em outro servidor, quer dizer, até pode ter colisão mas a probabilidade é hiperbaixa, perto de zero na prática. Eu menciono isso porque se procurar no VS Code olha só, Snowflake aparece em diversos lugares do código e achamos trechos que usam a função timefromidopt, onde passamos um ID de Snowflake e ele retorna um timestamp, daí podemos fazer operações como ver se foi criado antes ou depois de uma determinada data. Se estudar bancos de dados distribuídos, vai ver como existem diferentes estratégias de IDs únicos para diferentes necessidades. Um banco de dados como Cassandra usa outra estratégia chamada TimeUuID, que é muito similar, já que também tem um componente de timestamp embutido no ID, o que facilita fazer queries de períodos de tempo e análise de time series, que são séries de tempo e processamento de eventos. Um DynamoDB da Amazon tem um identificador único chamado de chave de partição, que é usado para particionar dados em múltiplos servidores no cluster. A chave de partição é combinado com uma chave de ordenação, que é usado para ordenar os dados dentro de uma partição. Sem fugir demais do assunto, mas já que eu falei disso, eu preciso pelo menos explicar outro conceito. Em bancos de dados distribuídos, um problema seria se um servidor fica mais cheio que outros servidores. Idealmente queremos balancear o volume de dados entre cada servidor, e uma das formas de fazer isso é o que chamamos de consistente hashing. Esse algoritmo mapeia chaves de partição, como o snowflake do Twitter ou TimeUuID do Cassandra, em nós virtuais num anel, um ring. Cada nó virtual representa um servidor físico no cluster. À medida que novos nó são adicionados ou removidos do cluster, os ranges de partição são redistribuídos por todos os nóis virtuais, garantindo distribuição uniforme das chaves de partição. E novamente, é um problema bem conhecido e bem resolvido nos mais diversos bancos de dados distribuídos. Eu lembro quando liamos papers da Amazon sobre isso, lá por 2008 ou 2009, mas para um estudante de ciência da computação. Hoje continua sendo um problema fascinante de entender, já que o conceito é bem simples. Um ID é muito mais do que só uma etiqueta qualquer. Ela serve para facilitar pesquisas e para facilitar balanceamento de sistemas distribuídos.
