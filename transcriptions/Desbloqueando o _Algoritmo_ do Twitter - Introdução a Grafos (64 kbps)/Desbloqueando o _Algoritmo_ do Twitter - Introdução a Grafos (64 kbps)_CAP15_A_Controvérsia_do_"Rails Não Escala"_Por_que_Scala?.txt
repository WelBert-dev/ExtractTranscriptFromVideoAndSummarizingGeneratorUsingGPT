E falando em Java, acho que vale a pena relembrar a parte inicial dessa história, o que aconteceu justamente em 2007 a 2010. Essa era a época que eu era mais participativa na comunidade Ruby on Rails e claro, o Twitter era um dos exemplos de maior sucesso de Rails, mas aí vem a notícia bombástica, o Twitter declarou que estava migrando de Ruby pra escala e daí veio o meme que não morre de Rails na escala. A forma como o Alex Spenney, um dos principais desenvolvedores do Twitter, descreveu ou melhor, não descreveu os problemas que estavam enfrentando, tudo que eu expliquei até aqui, causou má interpretação e muita gente falando muita merda. Eu conversei com outro dos principais desenvolvedores daquela época, Blaine Cook em junho de 2008 e mesmo naquela época eu também não tinha uma visão completa dos acontecimentos. Depois leio a entrevista original que está no meu blog. Por exemplo, da forma como o Alex Spenney falou, deu impressão que ele estava dizendo que Ruby on Rails não suportava conectar com múltiplos bancos de dados, que não era verdade. Sim, não tinha uma chavinha fácil, mas era basicamente uma linha extra que precisava ser colocada na classe pie de todos os activi records e dava pra selecionar onde fazer a conexão. Eu e vários outros descrevevam os tutoriais de como fazer isso. Mas a verdade é que o problema não era esse. Ninguém de fora do Twitter tinha muita noção do volume de dados que eles estavam tendo que lidar. E isso era 2007. Lembre-se, a Amazon AWS tinha lançado não fazia um ano. Produtos que hoje são a Roys com feijão, como SQS, DynamoDB, Route 53, nem tinham sido lançados ainda. Firebase ainda não existia. Porra, coisas como Redis ainda não tinha sido inventado. GitHub ainda não tinha sido inventado. A verdade é que particionar dados, organizar o MySQL em Sharks e conseguir fazer marketing e arquitetura coesa em cima disso não era trivial. E o Twitter estava numa fase de crescimento rápido. Não é que o Ruby on Rails não escalava pra escala do Twitter. Nada em Python escalaria. Nada em PHP escalaria. Node.js ainda não tinha sido inventado também, mas também não escalaria. Entenda, tinha poucas opções. Possivelmente a opção mais completa teria sido começar a implementar um banco de dados de grafos em cima de um Erlang, algo inspirado do banco de dados Minigia que vem no ATP de Erlang. Por exemplo, vocês já viram Erlang? Hoje ele ainda é pouco usado e em 2007 menos ainda. É verdade que grandes sistemas de telecomunicações já usavam fazia anos, mas eram um salto bem grande pra uma tech startup tomar. Quais as alternativas? Eles precisavam de uma linguagem pra escrever componentes como sistemas de fila, coisas no nível de Kafka. E lembrando que Kafka só seria lançado em 2011. Coisas no nível de Cassandra, que também só seria liberada publicamente pelo Facebook em 2008. Neo4j talvez fosse o componente mais próximo de se encaixar nos proeirões do Twitter, mas era super novo, tinha sido lançado em 2007. Entendem? Imagina você sendo desenvolvedor do Twitter, vendo milhares, centenas de milhares de tweets sendo postados todos os dias e tendo que lidar com grafos de usuários e tweets, sendo que algoritmos de grafos nunca tinham sido testados com volumes desse tipo. Numa época, onde toda tecnologia de cloud, no-sql e devops ainda não tinha sido inventado, onde linguagens mais comuns como Ruby, Python, PHP, JavaScript não estavam ajudando e programar em C++ ou Java parecia ser um passo pra trás. Elixir não tinha sido inventado ainda, Goa não tinha sido lançado ainda, Rust não tinha sido inventado ainda, LLVM ainda era uma grande novidade, já que a Apple tava só começando a mover suas ferramentas e linguagens de GCC pra Cileng, como o conto no episódio de Apple e GPL, mas havia uma única linguagem que talvez pudesse fazer sentido, a linguagem Scala, que tinha sido lançada em 2001 pelo visionário Martin Odersky. O Odersky é um desses gênios incomprendidos, tanto que tirando o povo da área de Java, eu duvido que qualquer um aqui já tenha ouvido falar dele, mas deveria. O cara é PhD de ciência da computação pela ITH de Zurich e trabalhou sob a supervisão de ninguém menos que Niklaus Wirff, o inventor de várias linguagens como o Modulador e Pascal, e o autor do livro de estrutura de dados e algoritmos que eu usei na faculdade. O Odersky participou e fez contribuições no mundo Java desde a versão 1.1, tendo trabalhado no compilador, na implementação de generics e algumas linguagens experimentais como a pizza e funnel, que influenciaram o design do Java. Muito antes de programação funcional ficar hypezinho de hipster sem graça como é hoje, no começo do século ele já vislumbrava uma linguagem que destilasse o melhor da orientação a objetos como os atrates, que são como protocolos de Objective C em vez de herança excessiva, mesclado com conceitos de programação funcional. Scala já tinha Higher Order Functions, já usava tipo opcional evitando os famosos no PointerException, Pattern Matching e tudo que se vê em linguagens mais modernas de hoje. Então era de fato a linguagem mais moderna que se podia escolher em 2007, mas rodando em cima da JVM que era a virtual machine mais madura que existia, dava pra criar aplicações que só seriam possíveis em C++ com uma fração da dor de cabeça. Pra isso custaria um pouco mais caro em uso de recursos do que se fosse puramente nativo, mas a JVM naquele ponto oferecia um ecossistema que ninguém mais tinha. E o objetivo do uso de Scala não era pra fazer front endzinho, era pra fazer os diversos componentes que eu expliquei que ainda não existiam. Começou com o projeto open source Starling, que é mais ou menos um mini-cáfrica alguns anos antes do Cáfrica, inventaram o Real Graph e GraphJet antes de um banco de dados de graps madura existir. Utilizaram coisas como Hadoop, que também faz parte do ecossistema Java. Nada disso teria sido possível sem C ou em Java ou em C++. Hoje em dia eles teriam muito mais opções, como o próprio Elixir, Go ou Rust Se quisessem arriscar linguagens mais exóticas, teriam TheNims, Zig, Talvez Swift, Kotlin, mais de novo, era 2006 pra 2007 e o relógio estava correndo. Em retrospecto foi uma decisão muito acertada, e é por isso que o código que foi liberado é dois terços Scala e Java e muito das pesquisas que o Twitter fez. Junto com trabalhos do Facebook, Google, Apple, Amazon, Geror, o atual ecossistema de linguagens, ferramentas e plataformas pra lidar com Big Data, Data Science, Machine Learning, culminando com Deep Learning e a atual geração de inteligência artificial que está todo mundo babando. Mas foi assim que as coisas começaram no início do século.
