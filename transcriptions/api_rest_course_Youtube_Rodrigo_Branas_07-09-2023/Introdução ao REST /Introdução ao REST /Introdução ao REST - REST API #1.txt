Fala galera! Sejam bem-vindos a nova série sobre REST, então ao longo dos episódios a ideia é falar sobre os fundamentos, métodos, códigos de retorno e também segurança, monitoramento, performance e até mesmo alternativas ao REST. Bom, você tá chegando agora, não deixe de se inscrever no canal e principalmente ativar as notificações, só assim você vai ficar sabendo de todas as novidades, todos os vídeos novos que a gente vem lançando todas as semanas. Bom, por falar em API, essa série tem o apoio da Link API que é uma plataforma completa de integração totalmente escalável e principalmente 100% brasileira e ela é feita de DEV para DEV. Então se você possui na tua empresa grandes desafios para o desenvolvimento de API, de integrações, automação, fluxos de negócio, então a tua empresa tá passando por aquela transformação digital, você precisa conhecer a Link API. Então basta clicar aqui no link da descrição e fazer um trial gratuito de 14 dias para você descobrir todo o poder da plataforma. Bom, então vamos lá, vamos começar. Muito bem, então para a gente começar a falar sobre REST é interessante primeiro discutir um pouco da ideia de API. Então API basicamente é uma interface de programação, ela significa application programming interface e como toda interface ela serve para permitir a interação, então quando um usuário vai interagir com a aplicação ele usa a interface gráfica, antigamente usava interface texto, ao passo que quando uma aplicação vai interagir com a outra, geralmente de forma programática, ela acaba usando uma API e ela não se restringe ao que a gente conhece hoje como as web APIs. Você tem API em bibliotecas e frameworks, que é esse conjunto de métodos de procedimentos públicos que eles ofertam numa espécie de contrato. Os sistemas operacionais em geral sempre expuseram muitas APIs, as aplicações em geral permitem uma interação programática para que elas possam colaborar entre si. Então, antigamente quando a gente falava em API era nisso que a gente pensava. As web APIs eram muito mais conhecidas como web services. Então, há 10 a 15 anos atrás, quando as integrações eram muito mais escasas, era normal para os serviços web ou web services. Esse conceito de interação entre sistema é relativamente antigo, ele é dos anos 80. Antes disso você tinha a ideia de EDI, de Electronic Data Interchange, que é basicamente trocado de arquivo que existe até hoje em muitos sistemas. Você coloca o arquivo numa pasta, o sistema de tempos em tempos lei processa esse arquivo. Agora, muitas tecnologias vêm evoluindo nos últimos décadas praticamente. Por exemplo, o DeCon e Corba são tecnologias um pouco mais antigas para a interação entre esses temas. O próprio RMI, para quem está acostumado com a arquitetura Java, já trabalhou com a EJBs, com Enterprise Java Beans, sabe que no seu Core você vai ter essa ideia da implementação do RMI, que é bem interessante, ela permite a geração de Stubs, então sem interagem de uma forma bem transparente. O próprio XML RPC que veio vindo a partir principalmente de 1998, o Dave Wiener, ele já começou a usar o protocolo HTTP como base para realizar essa interação entre os sistemas usantes ML. E aí, naturalmente, isso acabou dando origem ao Sope. O Sope acabou sendo justamente essa evolução, se tornou um padrão de mercado por bastante tempo. E é engraçado porque Sope significa Simple Object Access Protocol. E aí, hoje em dia, já trabalhou com Sope, principalmente com a integração, por exemplo, de notas fiscais eletrônicas, sabe que não é nem um pouco simples lidar com Sope. Depois, a gente começou a ver a evolução para REST, hoje em dia a gente vai falar bastante em GraphQL e até mesmo em GRPC. Bem, a partir de 2005, a gente começou a observar uma espécie de renascimento da web, principalmente do Ajax. Ajax é muita gente associa com a requisição, até pelo nome, Asynchronous JavaScript and XML. Não me lembro de ter usado o XML para fazer esse tipo de requisição. Mas, na verdade, o conceito de Ajax não tem relação somente com a requisição e não com a síncron. Isso é importante que seja dito. Um cara chamado Jesse James Garrett, em 2005, escreveu um artigo chamado A New Approach to Web Applications. E lá, olha que interessante, Defining Ajax. Ajax is a technology e aquele complementa. São várias tecnologias, todas. Ó, que legal. HTML, CSS, ADOM, Document Object Model, aquele cita também, XML, HTML, HTTP, Request, JavaScript. Então, quando a gente via aplicações que não faziam mais, refresh o tempo todo e traziam um experiência diferente para o usuário, então, que até se não chamar de Web 2.0, é mais ou menos disso que se trata o Ajax. A gente começou as aplicações ficando cada vez mais dinâmicas, cada vez mais usáveis. E aí, novas possibilidades passaram a se abrir. Vale lembrar que na época o Flash era um grande concorrente. Bom, de certa forma impulsionado por isso, a gente também começou a ver a separação de front-end, de back-end. Isso empurrou ainda mais o desenvolvimento das web APIs, porque naturalmente eu não uso mais esse tipo de recurso só para integrar certas funcionalidades de determinados tipos de sistemas. Eu uso, literalmente, um expor, um contrato, onde o meu front-end passa a interagir com o meu back-end. Então, a gente levou-se para outro nível. Deixou de fazer só server-side-handering e passou a expor um contrato completo que abrange praticamente todas as funcionalidades do sistema. Nessa mesma época, o negócio chamado Jason começou a se popularizar. Quem está na foto aí é o Douglas Crockford. O Douglas Crockford escreveu o livro JavaScript The Good Parts, que é um livro sensacional, mais antigo, claro, mas um livro muito bom sobre a linguagem JavaScript. E ele foi a pessoa que descobriu, ele não inventou, ele diz sempre em palestras que ele observou Jason na natureza. E aí ele escreveu uma especificação para passar a concorrer com o XML. Então, a gente viu uma série de movimentos como a substituição do XML pelo Jason, que traria menos burocracia para as aplicações, junto com uma separação de front-end e back-end e a evolução da tecnologia com a noção de Ajax e o desenvolvimento de aplicações mais ricas. Então, com tudo isso acontecendo de 2005 para cá, a gente passou a finalmente chegar nesse conceito que é o REST. Uma das formas que a gente tem para insultar qualquer pessoa que desenvolve software é dizer que a API não é REST. O API que ela está desenvolvendo não é REST, e acho que todo o mundo se pegou pensando se a sua API realmente é RESTful, é tipo aquele filme que a gente assiste várias vezes e acaba não entendendo. Muitas vezes a gente associa a noção de RESTful somente a um padrão de URL. Então, eu trouxe alguns exemplos aqui, por exemplo, Amazon.com, books, barra, uma idea. Você pensa assim, nossa, isso é RESTful, porque tem uma identificação de recurso, está orientado a recurso. Mas, southwest.com.barra, get flights with discounts, já não parece ser RESTful, porque eu estou falando de uma espécie de operação. Mas, youtube.com.barra, list video, será que é? Não sei, estou na dúvida, por causa do verbo. Netflix.com.barra, movies, só que tem um query string ali, eu falei que o gênero é comédia. Aí, poxa, será? Spotify.com.barra.songs, barro identificador, barra share, será que esse verbo faz sentido? Então, a gente se pega às vezes pensando, nossa, será que o certo é plural? Será que é singular quando eu trato a respeito de recursos? Será que eu posso usar verbos? Ou só posso usar substantivos? Muitas vezes, será que uma query string é permitida? Será que isso vai fazer com que a minha<|pt|><|zh|><|zh|> fundo seja RESTful ou não? O que eu diria é assim, não se preocupe tanto com isso. Porque normalmente a maior parte das API é, assim, teoricamente, acaba não sendo RESTful, por tudo��도록 que a gente vai ver a partir de Mas existem outros fatores que são muito mais importantes do que ser RESTFU e vale a pena dizer que a diferença entre uma coisa REST e RESTFU, basicamente é que tudo que é aderente a essa abordagem arquitetural chamada de REST é RESTFU. Então é só a forma como a gente interpreta e como a gente fala. O API que é aderente a essa abordagem arquitetural é dita RESTFU, tá bom? Então o mais importante é a gente entender como essa arquitetura foi modelada, quais são as suas restrições e principalmente as suas características. Bom, o conceito de REST foi abordado, ele foi definido por um cara chamado Roy Filding na sua análise de doutorado no ano 2000, tá? Já faz um certo tempo. De certa forma, isso já vinha a ser trabalhado muito antes pelo Roy, né? Vale lembrar que o Roy Filding ele trabalhou em várias especificações como RL, HTML, HTTP e antes não se chamava REST, se chamava HTTP ObjectModel e depois veio a ser renomeado, então até aqui a gente tem um email do Roy Filding falando um pouco sobre isso, tá? Bom, então essa tese ela tinha relação com um estilo arquitetural, né? De um sistema baseado na rede, né? Então quando a gente olha para isso rapidamente nos vem a mente que como ele trabalhava na web, ele está justamente descrevendo a web por meio dessa tese e REST é um dos capítulos que existem nessa tese, até eu acho muito interessante, eu estou deixando o link aqui no slide, né? E vou deixar aqui na descrição do vídeo também, para quem quiser ler depois dessa tese pode ser interessante, existem vários artigos também que simplificam um pouco a linguagem, mas você tem acesso também à tese, tá? REST é então a arquitetura que está relacionada com a web mais especificamente com protocolo HTTP, tá? Ela não tem relação direta com a construção de APIs. Por isso que é interessante a gente entender quais são as restrições arquiteturais de REST para que a gente justamente passe a entender se as APIs que a gente está construindo são RESTful, né? Então a primeira coisa é justamente a principal característica da web que é justamente ser client server, né? Em seguida, outra característica importante é ser stateless, ou seja, não existe estado entre as requisições, elas são todas independentes, tá? Tanto que em 94, já quatro anos depois do nascimento da web, quando eles foram, porque a web não nasceu para desenvolver aplicações, a web nasceu para compartilhar documentos, compartilhar literalmente arquivos, né? Então se deram conta que a web tinha um imenso potencial de distribuição e que a gente podia de certa forma gerar esses arquivos dinamicamente dando a impressão que são aplicações, faltava algumas peças nesse quebra-cabeça e isso foi resolvido com um conselho chamado Kuki, na ocasião para que eu possa marcar requisições, né? E aí permitir, por exemplo, carrinhos de compra que não se perdem quando eu recarrego a página, ou seja, quando eu navego entre páginas, tá bom? Então as requisições são totalmente independentes, apesar dessas requisições serem marcadas com muita frequência para fim de autenticação, de autorização, para que eu possa reconhecê-las, tá bom? Além disso, a web é o que a gente chama de Layered System, tá? Essa requisição, ela passa, ela atravessa por várias camadas até chegar ao seu destino, muitas vezes de auditoria, de autenticação, de autorização, é muito normal que isso aconteça, tá? Você tem Midwars, cada tipo de plataforma chama de uma coisa, né? Tem gente que chama de Filters, tem gente que chama de Interceptors, de Midwars, varia um pouquinho, todos eles servem para a mesma coisa, né? Uma característica muito marcante também é a possibilidade das requisições serem cacheadas, tá? Trazendo muito mais escalabilidade, muito mais performance, otimizando o consumo de recursos, aplicações muito grandes, com muito acesso, acabam fazendo um uso bem extensivo das caches, né? Bom, para a gente, quando a gente cruza esses conceitos com API, talvez um dos aspectos mais importantes seja o de interface uniforme, né? De uniforme interface, porque é isso que vai dar a navegabilidade, a independência, a granularidade na sua API, tá bom? Um dos pontos é justamente a identificação de recursos, tá? Então quando a gente pensa em REST, a gente está sempre pensando em recursos e todas as ações que a gente realiza, elas são realizadas em relação a recursos identificados. Então aqui, por exemplo, eu trouxe alguns exemplos, olha só, imagina API de Spotify, eu tenho lá um barra álbums, barra álbums, barra ID, então estou falando de um álbum específico, e nisso, olha só esse efeito da granularidade, né? Então dentro de um álbum eu tenho tracks, né? Eu tenho faixas, né? Esse álbum eu posso acessar uma faixa de forma específica, né? Barra tracks, barra ID, eu posso acessar um artista, né? Artist com ID ver os álbuns desse artista, né? Ver um usuário específico. Então repara que existe uma identificação de recurso e uma granularização sempre orientada a esses recursos. Outra restrição muito importante também é justamente a manipulação dos recursos por meio da sua representação. Eu estou trazendo os termos exatamente como eles estão dispostos na tese do Roy Fielding, né? E amplamente em diversos artigos que você pode acessar. Fácilmente por meio da web, tá? O que eu quero dizer com manipulação de recursos por meio da sua representação? Eu quero dizer o seguinte, que eu não vou, por meio da API, enviar uma espécie de comando para o back-end, seja esse comando um SQL, seja esse comando algum pedaço, alguma parte de um algoritmo, de uma linguagem, porque isso vai me gerar uma coisa chamada acoplamento, tá bom? Então a ideia é que eu modele recursos e a partir desses recursos eu use os métodos que estão disponíveis no protocolo HTTP para que eu realize transformações de estado nesses recursos. Então olha só que interessante. Eu vou criar uma nova faixa, então faço um post em barra tracks. Repare que o recurso é track. Bom, quando eu vou deletar eu faço barra tracks, barra ID. Quando eu vou, muitas vezes, atualizar, eu já vou usar um put, não mais um delete, e uso o mesmo barra tracks, barra ID. Então repare que eu estou sempre manipulando os recursos por meio da sua representação. Tá bom? Então esse é um outro fator também muito importante do REST, assim como as self descriptive messages, ou seja, cada uma das mensagens, quando eu digo mensagem, eu estou falando do conteúdo das requisições das respostas, devem ter informações que sejam suficientes para que eu realize todo tipo de transformação, de renderização e de tratamento. Então, por exemplo, eu estou retornando aqui o conteúdo de um álbum, por exemplo. Então, ou de um álbum ou de uma faixa. Então repare que eu tenho um content type. E eu estou dizendo, olha, esse content type é application JSON e o char set, o char set, o seu de codificação, ele é o TF 8. Bom, isso vai de certa forma orientar, seja o navegador, seja o back end, o servidor de aplicação, o servidor web, a processar essa requisição, essa resposta de uma determinada forma. Tá bom? Então é por isso que muitas vezes você recebe uma resposta e ela se converte no download de um arquivo, eu uso, às vezes, um content disposition, defino o nome do arquivo, defino a extensão, porque essa mensagem, ela tem uma descrição muito clara de como ela deve ser interpretada. Tá bom? Essa é uma outra restrição. E a última restrição dentro de uniforme interface é um dos conceitos que vão fazer com que a maior parte das API não seja RESTful. Até aqui, até esse ponto, você vai ver que a maior parte das APIs vão se ater a esses conceitos. São client server, stateless, passam por um layered system, caxáveis, tem um interface uniforme, de certa forma, elas têm uma identificação dos seus recursos, essa manipulação por meio da sua representação, mensagens autodiscritas, só que elas pecam. Eu não acho que isso seja um problema. Tá bom? No que o Roy Field chama de hypermedia as the engine of the application state. E hypermedia como uma espécie de máquina de estado da aplicação. E aqui vale a pena que a gente entenda o que isso quer dizer. O que ele tentou trazer? Quando eu estou navegando numa determinada página, eu normalmente não tenho um mapa do meu lado que eu fico olhando. Ah, para eu entrar aqui, imagina que eu esteja num site de notícias. Para entrar em economia, eu tenho que escrever na URL barra economia. Para que eu entre, por exemplo, em, de repente, política, eu boto barra política. Então eu não lido com uma espécie de mapa. Justamente a forma máquina de estado, ela está contida na página, está contida na mensagem por meio dos links. Tá bom? Então isso já é uma coisa muito natural para a gente. Quando eu entro numa página, eu vejo o link, se eu clico nos links, eu navego. É isso que faz a web ser essa espécie de teia ter essas interconexões. Tá bom? Muito bem. Eu vou trazer um exemplo aqui apenas, onde reparem na resposta, dentro do body dessa resposta, dentro desse Jason, eu trouxe aqui, olha, eu tenho o álbum aqui do artista Guns and Roses, o título é Appetite for Destruction. E aí, o que eu posso fazer com ele? Olha que interessante, eu tenho tracks. Então o álbum tem tracks. E para acessar essas tracks, eu vou fazer barra álbums, barro ID do álbum, barra tracks. Então quer dizer, eu trouxe uma certa dynamicidade, uma aplicação seria capaz de ler e montar uma máquina de estado a partir disso. Bom, isso não é uma coisa muito usada, eu não costumo ver tanto, já vi, mas não é tão comum assim. Isso pode trazer um pouco de dynamicidade, de resiliência para essa API, para que ela não quebre de uma forma assim tão rápida, tão fácil. Eu mudei o PATH de algum serviço, então ela vai se tornar um pouco mais resistente, mas não é tão comum. Geralmente vai ser por isso que uma API não é RESTful, não que isso seja um problema. Bem, existe uma outra restrição também no REST, que é o Code on Demand, quando você está numa página, eu baixo JavaScript, eu baixo CSS, eu baixo outros tipos de recursos, mas isso já não se aplica tanto a API. Mas importante a gente entender no REST que existe uma espécie de modelo de maturidade, o Richard som trouxe esse modelo, e ele definiu esses níveis. Então o nível zero, o que ele até chama de The Shump of Pox, Shump Pântano, e Pox é plain old XML. É como se eu não tivesse nada, eu não usasse verbos, códigos de retorno, não tivesse links, não tivesse absolutamente nada, não tivesse divisão de recursos, essa granularidade, eu simplesmente tivesse um endpoint, pedisse uma coisa e devolvei-se outra, sem qualquer critério, sem qualquer organização. É o que ele chama de Level Zero. Level Um, eu já estou granularizando essa API, eu já tenho uma hierarquização de recursos, já permito uma navegação um pouco mais clara, estou subindo, já estou usando verbos, para justamente, o que a gente falou lá, na manipulação dos recursos, para a sua representação. Então eu vou usar PuT para atualizar, Delete para deletar, Pox para criar. E aí o Level 3, que seria o nível máximo, eu já vi outros modos de maturidade, mas isso é muito conhecido. E aí já falem Hyper-Media Controls, muitas vezes essa ideia de Hyper-Media, as de Engine, of the application state que a gente acabou de falar. Bom, é importante a gente entender também que REST tem algumas, entre aspas, limitações, que pode ser que favoreçam a outras abordagens. Eu vou dar alguns exemplos aqui, por exemplo, olha só, peguei aqui o meu canal, se você não é inscrito, se inscreva. E aí imagina que isso seja um front-end e eu vá montar a partir de um back-end REST. Então eu tenho aqui, olha só, na letra A, eu imagino que eu vá fazer um barra channel os barra ID, para trazer o nome do canal, o número de inscritos. E na B eu já vou trazer as playlists, então barra de channel, barra ID, barra playlists, e depois para cada uma das playlists eu vou trazer os vídeos. Entende que essa abordagem pode fazer com que eu tenha das duas uma, ou overfating, que é quando eu trago coisa de mais desnecessária, por exemplo, eu tenho uma tabela no banco com 100 colunas, eu trago sempre as 100 colunas. Para que o problema é underfating, quer dizer, eu vou ter que no meu front-end fazer um aço, fazer um for, para cada playlist que tiver no arrei eu faço uma requisição a mais trazendo os vídeos, porque eu não tenho um barra playlists with videos, eu iria quebrar essa granularização. Então isso pode ser resolvido de algumas formas, algumas pessoas acabam deixando a interface gráfica orientada aos recursos devolvidos em cada nível e erárquico da PI, então ela se parece com PHP mais de mim, como se estivesse navegando em tabelas de um banco de dados, não faz sentido. Você vai acabar tendo uma usabilidade muito a quem do que poderia ser, então eu entro aqui, eu só vejo o channel, só vejo o canal, agora eu clico aqui, eu só vejo lista de playlists, agora eu clico aqui e vejo os vídeos da playlist, mas eu não tenho tanta riqueza na interface gráfica. E é por isso que existem algumas outras abordagens, por exemplo BFF, Back End, For Front End, que eu já crio uma espécie de sub-APIs segmentada por cliente capaz de orquestrar serviços de Back End. Muito interessante essa técnica, então ela pode trazer uma certa robustez nessa PI para adequar a cada um dos consumidores. O próprio GraphQL, que é uma linguagem de consulta e mutação, que aliás aqui no canal tem vários vídeos sobre GraphQL, tem lives, tem séries, onde eu escrevo uma linguagem, por meio de uma linguagem eu escrevo uma consulta e peço exatamente os dados da forma como eu preciso. GRPC, que é bem interessante também, onde eu tenho um protobuf, um protocolo mais orientado, não somente a JSON, mas de uma forma binária, onde eu tenho uma leveza maior, eu gera uma espécie de stub, que me traz um pouco mais de transparência, então para interagir entre Back End, pode ser interessante. Então se repara que existem algumas alternativas, que a gente pode detalhar nos próximos episódios dessa série, mas que o REST tem uma capacidade muito grande de modelagem de definir APIs extremamente reusáveis, que para mim talvez seja o aspecto fundamental mais importante, eu tenho uma API simples, fácil de navegar, que atenda a maior parte de clientes possíveis, que justamente cumpra o seu objetivo e suporte o crescimento não só do sistema, a qual ela faz parte, mas também dos sistemas que estão ao redor dela. Bom, muito bem, então essa foi uma forma de introduzir o REST, nos próximos episódios que vou pretendo falar sobre segurança, sobre monitoramento, sobre documentação, trazer um pouco mais de certa forma dessas alternativas, dar um pouco mais de exemplos, entrar um pouco mais a fundo nos verbos, nos códigos de retorno, trazer alguns exemplos mais práticos, então eu te vejo no próximo vídeo e até lá. Valeu pessoal!